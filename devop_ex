ex:1 git essential - commit
git init 
git add .
git commit -m "initial commit"
git remote add origin https://github.com/manojmr23/ABC.git
git push -u origin main. If this error occurs, use this command ( git branch -m main) and redo this push  command again  repit git push -u origin main

git checkout -b feature-branch
echo "Feature branch update" >> demo.txt
git add .
git commit -m "Added demo.txt for pull request test"
git push origin feature-branch





exp2  docker container and image 
Exp 2 :
mkdir docker
cd docker

create index.html file 

create docker file 

FROM nginx 
COPY index.html /usr/share/nginx/html/index.html

docker build -t myweb:v1 .

docker run -d -p 9090:80 myweb:v1






EXP 3: flask app contain and dockerhub
flask-docker-app/
‚îú‚îÄ‚îÄ app.py
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ Dockerfile

app.py 

from flask import Flask, render_template_string

app = Flask(_name_)
@app.route('/')
def home():
    return render_template_string("<h1>Welcome to the Flask Docker App!</h1>")
if _name_ == '_main_':
    app.run(host='0.0.0.0', port=5000)

requirements.txt

Flask==2.2.5


Dockerfile

FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]


docker build -t flask-docker-app .

docker run -p 5000:5000 flask-docker-app


EXP 4: ci pipeline 
GOAL
----
You will create a tiny plain Python application and set up a GitHub Actions workflow that:
1) Runs tests with pytest
2) Builds a Docker image
3) Pushes the image to Docker Hub
4) (Optional) Publishes a release tag like v1.0.0
PREREQUISITES
-------------
- GitHub account
- Docker Hub account
- Git installed locally
- Python 3.11+
- Docker Desktop (optional for local testing)
STEP 1 ‚Äî Create a new project folder
------------------------------------
mkdir python-ci-docker-lab
cd python-ci-docker-lab
STEP 2 ‚Äî Create application files
---------------------------------
app.py
------
def add(a, b):
return a + b
if __name__ == "__main__":
print("Hello from Python CI Lab!")
print("2 + 3 =", add(2, 3))

tests/
    test_app.py
-----------------
from app import add
def test_add():
assert add(2, 3) == 5
assert add(-1, 1) == 0

requirements.txt
----------------
pytest==8.3.2


Dockerfile
----------
FROM python:3.11-slim


WORKDIR /
    app
COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt
COPY . .
CMD ["python", "app.py"]


.gitignore
----------
__pycache__/
.venv/
.pytest_cache/
.DS_Store
*.pyc


STEP 3 ‚Äî Add GitHub Actions workflow
------------------------------------
mkdir -p .github/workflows

.github/
    workflows/
        ci-dockerhub.yml
----------------------------------
name: ci-dockerhub
on:
push:
branches: [ "main" ]
tags: [ "*" ]
pull_request:
branches: [ "main" ]
jobs:
build-test-push:
runs-on: ubuntu-latest
steps:
- name: Checkout
uses: actions/checkout@v4
- name: Set up Python
uses: actions/setup-python@v5
with:
python-version: '3.11'
- name: Install deps
run: |
python -m pip install --upgrade pip
pip install -r requirements.txt
- name: Run tests
run: pytest -q
- name: Docker meta
id: meta
uses: docker/metadata-action@v5
with:
images: ${{ secrets.DOCKERHUB_USERNAME }}/python-ci-lab

tags: |
type=raw,value=latest,enable={{is_default_branch}}
type=sha,prefix=sha-,format=short
type=ref,event=tag
- name: Set up QEMU
uses: docker/setup-qemu-action@v3
- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v3
- name: Login to Docker Hub
uses: docker/login-action@v3
with:
username: ${{ secrets.DOCKERHUB_USERNAME }}
password: ${{ secrets.DOCKERHUB_TOKEN }}
- name: Build and push
uses: docker/build-push-action@v6
with:
context: .
push: true
tags: ${{ steps.meta.outputs.tags }}
labels: ${{ steps.meta.outputs.labels }}
platforms: linux/amd64


STEP 4 ‚Äî Test locally (optional)
--------------------------------
python app.py
pytest -q
docker build -t yourname/python-ci-lab:local .
docker run --rm yourname/python-ci-lab:local


STEP 5 ‚Äî Initialize Git & push to GitHub
----------------------------------------
git init
git add .
git commit -m "init lab"
git branch -M main
git remote add origin https://github.com/<your-username>/python-ci-docker-lab.git
git push -u origin main
STEP 6 ‚Äî Add GitHub Secrets
---------------------------
- DOCKERHUB_USERNAME (your Docker Hub username)
- DOCKERHUB_TOKEN (Docker Hub access token)


STEP 7 ‚Äî Watch CI run
---------------------
Go to GitHub ‚Üí Actions tab ‚Üí select workflow run ‚Üí view logs.


STEP 8 ‚Äî Verify image on Docker Hub
-----------------------------------
docker.io/<DOCKERHUB_USERNAME>/python-ci-lab

STEP 9 ‚Äî Release with a tag (optional)
--------------------------------------
git tag v1.0.0
git push origin v1.0.0

TROUBLESHOOTING
---------------
- Docker login failed ‚Üí Check token
- No image ‚Üí Inspect build logs
- Tests failing ‚Üí Run pytest locally
- Port in use ‚Üí Use docker run -p 8080:8000

STRETCH GOALS
-------------
- Add staging/prod environments with approvals
- Publish to GHCR/ACR
- Add image scanning
- Deploy to AKS/ECS/App Service




ex: 5 jenkins

This lab teaches, how to use Jenkins running in Docker to generate and publish a simple static website
(Karunya University example) using a pipeline. Learn how to:
Run Jenkins with Docker Compose.
Write a Jenkinsfile to create a static website.
Use the HTML Publisher plugin to display the site inside Jenkins.
Archive build artifacts.

Prerequisites
Laptop or VM with Docker and Docker Compose installed.
Internet access to pull Docker images.
Jenkins running inside Docker ( jenkins/jenkins:lts ).
Basic knowledge of Git and command line.

Step 1: Set up Jenkins with Docker Compose
1.Create a folder for the lab:
mkdir ~/jenkins-static-site && cd ~/jenkins-static-site
2.Create a docker-compose.yml file:
version: '3.8'
services:
jenkins:
image: jenkins/jenkins:lts
container_name: jenkins
restart: unless-stopped
ports:
- "8080:8080"
- "50000:50000"
volumes:
- jenkins_home:/var/jenkins_home
- /var/run/docker.sock:/var/run/docker.sock

volumes:
jenkins_home:
driver: local

3.Start Jenkins:
docker compose up -d
4.Get the initial admin password:
docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword

Open Jenkins in the browser: http://localhost:8080
Complete setup ‚Üí install suggested plugins ‚Üí create admin user.

Step 2: Install HTML Publisher Plugin
In Jenkins: Manage Jenkins ‚Üí Plugins ‚Üí Available Plugins.
Search for HTML Publisher and install it.
Restart Jenkins if prompted.

Step 3: Create the Pipeline Job
In Jenkins, click New Item ‚Üí select Pipeline ‚Üí name it karunya-site-pipeline .
Scroll to Pipeline ‚Üí Definition and select Pipeline script.
Paste the following script:
code:

pipeline {
agent any
stages {
stage('Generate site') {
steps {
script {
sh 'rm -rf site || true'
sh 'mkdir -p site/assets'
writeFile file: 'site/index.html', text: """

<!doctype html>
<html lang=\"en\">
<head>
<meta charset=\"utf-8\"/>

<meta name=\"viewport\" content=\"width=device-width, initial-
scale=1\"/>

<title>Karunya University ‚Äî Simple Site</title>
<link rel=\"stylesheet\" href=\"assets/style.css\"/>
</head>
<body>
<header class=\"site-header\">
<div class=\"container\">
<h1>Karunya University</h1>
<p class=\"tagline\">Values ‚Äî Knowledge ‚Äî Service</p>
</div>
</header>
<main class=\"container\">
<section class=\"card\">
<h2>About Karunya University</h2>
<p>Karunya Institute of Technology and Sciences is a leading
centre for higher education in India.</p>
</section>
</main>
<footer class=\"site-footer container\">
<p>&copy; ${new Date().format('yyyy')} Karunya University ‚Äî
Generated by Jenkins</p>
</footer>
</body>
</html>
"""

writeFile file: 'site/assets/style.css', text: """
body { font-family: Arial, sans-serif; margin:0; }
.container { max-width:800px; margin:0 auto; padding:20px; }
.site-header { background:#0b3d91; color:#fff; padding:20px; }
.tagline { font-size:14px; opacity:0.8; }
.card { background:#fff; border:1px solid #ddd; padding:15px; margin:
15px 0; border-radius:6px; }

.site-footer { text-align:center; font-size:12px; color:#555; margin-
top:20px; }

"""
}
}
}
stage('Publish site') {
steps {
publishHTML ([
allowMissing: false,

alwaysLinkToLastBuild: true,
keepAll: true,
reportDir: 'site',
reportFiles: 'index.html',
reportName: 'Karunya University - Simple Site'
])
}
}
}
post {
always {
archiveArtifacts artifacts: 'site/**', fingerprint: true
}
}
}


Save the pipeline.

Step 4: Run and View the Website
Click Build Now.
After success, go to the build page.
On the left menu, click Karunya University - Simple Site.
You should see the static site rendered inside Jenkins.
Alternatively, download the archived artifact (the site/ folder) and open index.html locally.






ex 6:kubernetes resource using cli

    Prerequisites
‚óè Laptop/desktop with at least 4 GB RAM and internet access.
‚óè One of these OS options: Ubuntu/Debian Linux, macOS, or Windows 10/11.
‚óè Basic terminal or PowerShell familiarity.

Quick Checklist Before You Start
‚óè Terminal (Linux/macOS) or PowerShell (Windows) ready.
‚óè Admin/sudo access to install software.
‚óè Docker and Minikube installed.

Install the Tools
We will use Minikube for the local Kubernetes cluster. It runs a single-node cluster inside
Docker.
You need: Docker (or Docker Desktop), kubectl, and Minikube.

A. Install Docker
Windows:
1. Download and install Docker Desktop from Docker's website.
2. Enable WSL2 backend during installation.
3. Start Docker Desktop and ensure it is running.

Verify Docker installation:
docker --version

B. Install kubectl (Kubernetes CLI)
Windows (using Chocolatey):
choco install kubernetes-cli

Verify installation:
kubectl version --client

C. Install and Start Minikube
Windows (using Chocolatey):
choco install minikube
minikube start --driver=docker

Verify the cluster is running:
minikube status
kubectl get nodes

If kubectl get nodes returns a node in Ready state ‚Äî you are ready to go!

üß© Step 1: Create a Simple Pod

1. Create a file: nginx-pod.yaml

apiVersion: v1
kind: Pod
metadata:
name: nginx-pod
labels:
app: nginx
spec:
containers:
- name: nginx
image: nginx:latest
ports:
- containerPort: 80

Apply the manifest:
kubectl apply -f nginx-pod.yaml

Check pod status:
kubectl get pods
# expected: nginx-pod 1/1 Running

Describe the pod (to see detailed info):
kubectl describe pod nginx-pod

Forward the port locally to access it in the browser:
kubectl port-forward pod/nginx-pod 8080:80

Then open http://localhost:8080 in your browser.
When done, delete the pod:
kubectl delete pod nginx-pod

üß© Step 2: Deployment and Scaling

Create a deployment:

kubectl create deployment my-nginx --image=nginx

Check deployments and pods:

kubectl get deployments
kubectl get pods -l app=my-nginx

Scale to 3 replicas:

kubectl scale deployment my-nginx --replicas=3
kubectl get pods

Update the image (rolling update):

kubectl set image deployment/my-nginx nginx=nginx:1.25
kubectl rollout status deployment/my-nginx

If something goes wrong, rollback:

kubectl rollout undo deployment/my-nginx

üß© Step 3: Expose Deployment as a Service
Expose the deployment using a NodePort service:

kubectl expose deployment my-nginx --type=NodePort --port=80
kubectl get svc

Get the URL of your app using Minikube:

minikube service my-nginx --url

Open the displayed URL in your browser.

To remove the service:

kubectl delete svc my-nginx

üßπ Step 4: Cleanup
After the lab, clean up all created resources:

kubectl delete deployment my-nginx
kubectl delete svc my-nginx
kubectl delete all --all -n default

If you want to stop or delete the cluster:

minikube stop
minikube delete

üßæ Summary
In this lab, you learned how to:
1. Install Docker, kubectl, and Minikube.
2. Create and manage Pods.
3. Deploy and scale applications.
4. Expose Deployments as services.
5. Clean up resources safely.





ex 7: kubernet deployment and service for the python app from the docker hub
 

 Prerequisites
‚óè Minikube and kubectl installed
‚óè Docker Desktop running
‚óè Internet connectivity to pull the Docker image from Docker Hub

Setup Verification
minikube start --driver=docker
kubectl get nodes
Ensure the node status is Ready.

üß© Step 1: Choose a Python Docker Image
We‚Äôll use a simple Python web app image hosted on Docker Hub.
You can use any public Python web app image, such as:


docker.io/python:3.9-slim


or for demonstration, use a prebuilt sample (replace <username> with your Docker Hub
username if using your own image):

docker.io/dockersamples/flaskapp

You can verify Docker Hub accessibility by:

docker pull dockersamples/flaskapp

üß© Step 2: Create a Kubernetes Deployment
Create a file named python-deployment.yaml:


apiVersion: apps/v1
kind: Deployment
metadata:
name: python-web-deployment
labels:
app: python-web
spec:
replicas: 2
selector:
matchLabels:
app: python-web
template:
metadata:
labels:
app: python-web
spec:
containers:
- name: python-web
image: dockersamples/flaskapp:latest
ports:
- containerPort: 5000


Apply the deployment:

kubectl apply -f python-deployment.yaml

Check status:

kubectl get deployments
kubectl get pods

View details:

kubectl describe deployment python-web-deployment

üß© Step 3: Expose Deployment as a Service

Now expose your Python app using a NodePort Service.

Create a file python-service.yaml:

apiVersion: v1
kind: Service
metadata:
name: python-web-service
spec:
type: NodePort
selector:
app: python-web
ports:
- protocol: TCP
port: 5000
targetPort: 5000

Apply it:

kubectl apply -f python-service.yaml

Check if the service is created:

kubectl get svc

Get Minikube service URL:

minikube service python-web-service --url
Open the displayed URL in your browser. You should see the Python web app page.

üßπ Step 4: Cleanup
After the lab, clean up all created resources:
If you want to stop or delete the cluster:

minikube stop
minikube delete

üßæ Summary
In this lab, you learned how to:
1. Pull a containerized Python app from Docker Hub
2. Deploy it on a Kubernetes cluster using a Deployment
3. Expose it via a Service (NodePort)
4. Access the running app through Minikube
