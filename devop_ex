ex:1 git essential - commit
git init 
git add .
git commit -m "initial commit"
git remote add origin https://github.com/manojmr23/ABC.git
git push -u origin main. If this error occurs, use this command ( git branch -m main) and redo this push  command again  repit git push -u origin main

git checkout -b feature-branch
echo "Feature branch update" >> demo.txt
git add .
git commit -m "Added demo.txt for pull request test"
git push origin feature-branch





exp2  docker container and image 
Exp 2 :
mkdir docker
cd docker

create index.html file 

create docker file 

FROM nginx 
COPY index.html /usr/share/nginx/html/index.html

docker build -t myweb:v1 .

docker run -d -p 9090:80 myweb:v1






EXP 3: flask app contain and dockerhub
flask-docker-app/
‚îú‚îÄ‚îÄ app.py
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ Dockerfile

app.py 

from flask import Flask, render_template_string

app = Flask(_name_)
@app.route('/')
def home():
    return render_template_string("<h1>Welcome to the Flask Docker App!</h1>")
if _name_ == '_main_':
    app.run(host='0.0.0.0', port=5000)

requirements.txt

Flask==2.2.5


Dockerfile

FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]


docker build -t flask-docker-app .

docker run -p 5000:5000 flask-docker-app


EXP 4: ci pipeline 
mkdir jenkins-static-site  
cd jenkins-static-site

docker-compose.yml

version: '3.8'

services:
  jenkins:
    image: jenkins/jenkins:lts
    container_name: jenkins
    restart: unless-stopped
    ports:
      - "8080:8080"
      - "50000:50000"
    volumes:
      - jenkins_home:/var/jenkins_home
      - ./jenkins-config:/usr/share/jenkins/ref
      - /var/run/docker.sock:/var/run/docker.sock
volumes:
  jenkins_home:
    driver: local


docker compose up -d


docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword


if any error came u can do this
docker compose down
>> docker compose up -d






ex: 5 jenkins

This lab teaches, how to use Jenkins running in Docker to generate and publish a simple static website
(Karunya University example) using a pipeline. Learn how to:
Run Jenkins with Docker Compose.
Write a Jenkinsfile to create a static website.
Use the HTML Publisher plugin to display the site inside Jenkins.
Archive build artifacts.

Prerequisites
Laptop or VM with Docker and Docker Compose installed.
Internet access to pull Docker images.
Jenkins running inside Docker ( jenkins/jenkins:lts ).
Basic knowledge of Git and command line.

Step 1: Set up Jenkins with Docker Compose
1.Create a folder for the lab:
mkdir ~/jenkins-static-site && cd ~/jenkins-static-site
2.Create a docker-compose.yml file:
version: '3.8'
services:
jenkins:
image: jenkins/jenkins:lts
container_name: jenkins
restart: unless-stopped
ports:
- "8080:8080"
- "50000:50000"
volumes:
- jenkins_home:/var/jenkins_home
- /var/run/docker.sock:/var/run/docker.sock

volumes:
jenkins_home:
driver: local

3.Start Jenkins:
docker compose up -d
4.Get the initial admin password:
docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword

Open Jenkins in the browser: http://localhost:8080
Complete setup ‚Üí install suggested plugins ‚Üí create admin user.

Step 2: Install HTML Publisher Plugin
In Jenkins: Manage Jenkins ‚Üí Plugins ‚Üí Available Plugins.
Search for HTML Publisher and install it.
Restart Jenkins if prompted.

Step 3: Create the Pipeline Job
In Jenkins, click New Item ‚Üí select Pipeline ‚Üí name it karunya-site-pipeline .
Scroll to Pipeline ‚Üí Definition and select Pipeline script.
Paste the following script:
code:

pipeline {
agent any
stages {
stage('Generate site') {
steps {
script {
sh 'rm -rf site || true'
sh 'mkdir -p site/assets'
writeFile file: 'site/index.html', text: """

<!doctype html>
<html lang=\"en\">
<head>
<meta charset=\"utf-8\"/>

<meta name=\"viewport\" content=\"width=device-width, initial-
scale=1\"/>

<title>Karunya University ‚Äî Simple Site</title>
<link rel=\"stylesheet\" href=\"assets/style.css\"/>
</head>
<body>
<header class=\"site-header\">
<div class=\"container\">
<h1>Karunya University</h1>
<p class=\"tagline\">Values ‚Äî Knowledge ‚Äî Service</p>
</div>
</header>
<main class=\"container\">
<section class=\"card\">
<h2>About Karunya University</h2>
<p>Karunya Institute of Technology and Sciences is a leading
centre for higher education in India.</p>
</section>
</main>
<footer class=\"site-footer container\">
<p>&copy; ${new Date().format('yyyy')} Karunya University ‚Äî
Generated by Jenkins</p>
</footer>
</body>
</html>
"""

writeFile file: 'site/assets/style.css', text: """
body { font-family: Arial, sans-serif; margin:0; }
.container { max-width:800px; margin:0 auto; padding:20px; }
.site-header { background:#0b3d91; color:#fff; padding:20px; }
.tagline { font-size:14px; opacity:0.8; }
.card { background:#fff; border:1px solid #ddd; padding:15px; margin:
15px 0; border-radius:6px; }

.site-footer { text-align:center; font-size:12px; color:#555; margin-
top:20px; }

"""
}
}
}
stage('Publish site') {
steps {
publishHTML ([
allowMissing: false,

alwaysLinkToLastBuild: true,
keepAll: true,
reportDir: 'site',
reportFiles: 'index.html',
reportName: 'Karunya University - Simple Site'
])
}
}
}
post {
always {
archiveArtifacts artifacts: 'site/**', fingerprint: true
}
}
}


Save the pipeline.

Step 4: Run and View the Website
Click Build Now.
After success, go to the build page.
On the left menu, click Karunya University - Simple Site.
You should see the static site rendered inside Jenkins.
Alternatively, download the archived artifact (the site/ folder) and open index.html locally.






ex 6:kubernetes resource using cli

    Prerequisites
‚óè Laptop/desktop with at least 4 GB RAM and internet access.
‚óè One of these OS options: Ubuntu/Debian Linux, macOS, or Windows 10/11.
‚óè Basic terminal or PowerShell familiarity.

Quick Checklist Before You Start
‚óè Terminal (Linux/macOS) or PowerShell (Windows) ready.
‚óè Admin/sudo access to install software.
‚óè Docker and Minikube installed.

Install the Tools
We will use Minikube for the local Kubernetes cluster. It runs a single-node cluster inside
Docker.
You need: Docker (or Docker Desktop), kubectl, and Minikube.

A. Install Docker
Windows:
1. Download and install Docker Desktop from Docker's website.
2. Enable WSL2 backend during installation.
3. Start Docker Desktop and ensure it is running.

Verify Docker installation:
docker --version

B. Install kubectl (Kubernetes CLI)
Windows (using Chocolatey):
choco install kubernetes-cli

Verify installation:
kubectl version --client

C. Install and Start Minikube
Windows (using Chocolatey):
choco install minikube
minikube start --driver=docker

Verify the cluster is running:
minikube status
kubectl get nodes

If kubectl get nodes returns a node in Ready state ‚Äî you are ready to go!

üß© Step 1: Create a Simple Pod

1. Create a file: nginx-pod.yaml

apiVersion: v1
kind: Pod
metadata:
name: nginx-pod
labels:
app: nginx
spec:
containers:
- name: nginx
image: nginx:latest
ports:
- containerPort: 80

Apply the manifest:
kubectl apply -f nginx-pod.yaml

Check pod status:
kubectl get pods
# expected: nginx-pod 1/1 Running

Describe the pod (to see detailed info):
kubectl describe pod nginx-pod

Forward the port locally to access it in the browser:
kubectl port-forward pod/nginx-pod 8080:80

Then open http://localhost:8080 in your browser.
When done, delete the pod:
kubectl delete pod nginx-pod

üß© Step 2: Deployment and Scaling

Create a deployment:

kubectl create deployment my-nginx --image=nginx

Check deployments and pods:

kubectl get deployments
kubectl get pods -l app=my-nginx

Scale to 3 replicas:

kubectl scale deployment my-nginx --replicas=3
kubectl get pods

Update the image (rolling update):

kubectl set image deployment/my-nginx nginx=nginx:1.25
kubectl rollout status deployment/my-nginx

If something goes wrong, rollback:

kubectl rollout undo deployment/my-nginx

üß© Step 3: Expose Deployment as a Service
Expose the deployment using a NodePort service:

kubectl expose deployment my-nginx --type=NodePort --port=80
kubectl get svc

Get the URL of your app using Minikube:

minikube service my-nginx --url

Open the displayed URL in your browser.

To remove the service:

kubectl delete svc my-nginx

üßπ Step 4: Cleanup
After the lab, clean up all created resources:

kubectl delete deployment my-nginx
kubectl delete svc my-nginx
kubectl delete all --all -n default

If you want to stop or delete the cluster:

minikube stop
minikube delete

üßæ Summary
In this lab, you learned how to:
1. Install Docker, kubectl, and Minikube.
2. Create and manage Pods.
3. Deploy and scale applications.
4. Expose Deployments as services.
5. Clean up resources safely.





ex 7: kubernet deployment and service for the python app from the docker hub
 

 Prerequisites
‚óè Minikube and kubectl installed
‚óè Docker Desktop running
‚óè Internet connectivity to pull the Docker image from Docker Hub

Setup Verification
minikube start --driver=docker
kubectl get nodes
Ensure the node status is Ready.

üß© Step 1: Choose a Python Docker Image
We‚Äôll use a simple Python web app image hosted on Docker Hub.
You can use any public Python web app image, such as:


docker.io/python:3.9-slim


or for demonstration, use a prebuilt sample (replace <username> with your Docker Hub
username if using your own image):

docker.io/dockersamples/flaskapp

You can verify Docker Hub accessibility by:

docker pull dockersamples/flaskapp

üß© Step 2: Create a Kubernetes Deployment
Create a file named python-deployment.yaml:


apiVersion: apps/v1
kind: Deployment
metadata:
name: python-web-deployment
labels:
app: python-web
spec:
replicas: 2
selector:
matchLabels:
app: python-web
template:
metadata:
labels:
app: python-web
spec:
containers:
- name: python-web
image: dockersamples/flaskapp:latest
ports:
- containerPort: 5000


Apply the deployment:

kubectl apply -f python-deployment.yaml

Check status:

kubectl get deployments
kubectl get pods

View details:

kubectl describe deployment python-web-deployment

üß© Step 3: Expose Deployment as a Service

Now expose your Python app using a NodePort Service.

Create a file python-service.yaml:

apiVersion: v1
kind: Service
metadata:
name: python-web-service
spec:
type: NodePort
selector:
app: python-web
ports:
- protocol: TCP
port: 5000
targetPort: 5000

Apply it:

kubectl apply -f python-service.yaml

Check if the service is created:

kubectl get svc

Get Minikube service URL:

minikube service python-web-service --url
Open the displayed URL in your browser. You should see the Python web app page.

üßπ Step 4: Cleanup
After the lab, clean up all created resources:
If you want to stop or delete the cluster:

minikube stop
minikube delete

üßæ Summary
In this lab, you learned how to:
1. Pull a containerized Python app from Docker Hub
2. Deploy it on a Kubernetes cluster using a Deployment
3. Expose it via a Service (NodePort)
4. Access the running app through Minikube
